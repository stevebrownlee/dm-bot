from pydantic_ai import (
    ModelMessage, UserPromptPart, ModelRequest,
    SystemPromptPart, TextPart
)
from pydantic_ai.messages import ToolReturnPart


def summarize_old_messages(messages: list[ModelMessage], limit: int = 20) -> list[ModelMessage]:
    """
    Summarize old messages using a fast model.

    Args:
        messages: List of messages to process
        limit: Number of recent messages to keep unsummarized (default is 20)

    Returns:
        A new list with old messages replaced by summaries
    """
    if len(messages) <= limit:
        return messages

    # Extract text content from the first 'limit' messages
    recent_messages = messages[-limit:]

    # For demonstration, we'll just concatenate the old messages into a single summary
    # In a real implementation, you would use a fast model to generate a proper summary
    old_messages_text = []
    for msg in messages[:-limit]:
        for part in msg.parts:
            # Check for specific part types that have content
            if isinstance(part, (UserPromptPart, SystemPromptPart, TextPart)):
                old_messages_text.append(part.content)
    # Create a summary message (in practice, this would be generated by a model)
    summary_content = "Summary of previous conversation: " + " ".join(old_messages_text[:100])  # Limit to first 100 words

    # Create a new ModelMessage for the summary
    summary_message = ModelRequest(
        parts=[UserPromptPart(content=summary_content)],
        run_id="summary-" + str(len(messages))
    )

    # Return recent messages plus the summary message at the beginning
    return [summary_message] + recent_messages


def dm_history_processor(messages: list[ModelMessage]) -> list[ModelMessage]:
    """Keep recent conversation turns (user message + agent response as units)."""

    if len(messages) <= 20:
        return messages

    # Keep last 20 messages, but adjust to safe boundary
    target_length = 20

    # Work backwards from the end
    safe_messages = []
    i = len(messages) - 1

    while i >= 0 and len(safe_messages) < target_length:
        msg = messages[i]
        safe_messages.insert(0, msg)

        # If we added a tool return, make sure we include its call
        if i > 0 and any(isinstance(part, ToolReturnPart) for part in msg.parts):
            # Add the previous message (should be the tool call)
            safe_messages.insert(0, messages[i-1])
            i -= 1

        i -= 1

    return safe_messages